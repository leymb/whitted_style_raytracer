head     1.231139;
access   ;
symbols  ;
locks    ;comment  @@;


1.231139
date     2021.01.22.13.16.13;  author p4;  state Exp;
branches ;
next     1.230304;

1.230304
date     2021.01.20.19.11.22;  author p4;  state Exp;
branches ;
next     1.229956;

1.229956
date     2021.01.20.14.48.36;  author p4;  state Exp;
branches ;
next     1.228854;

1.228854
date     2021.01.18.17.19.05;  author p4;  state Exp;
branches ;
next     1.228236;

1.228236
date     2021.01.15.16.05.29;  author p4;  state Exp;
branches ;
next     1.228098;

1.228098
date     2021.01.15.10.15.13;  author p4;  state Exp;
branches ;
next     1.225070;

1.225070
date     2021.01.08.18.36.19;  author p4;  state Exp;
branches ;
next     1.225059;

1.225059
date     2021.01.08.17.21.59;  author p4;  state Exp;
branches ;
next     1.223997;

1.223997
date     2021.01.06.14.49.15;  author p4;  state Exp;
branches ;
next     1.223122;

1.223122
date     2021.01.04.16.35.41;  author p4;  state Exp;
branches ;
next     1.222449;

1.222449
date     2020.12.18.15.25.10;  author p4;  state Exp;
branches ;
next     1.222434;

1.222434
date     2020.12.18.14.31.55;  author p4;  state Exp;
branches ;
next     1.222417;

1.222417
date     2020.12.18.14.02.50;  author p4;  state Exp;
branches ;
next     1.222402;

1.222402
date     2020.12.18.13.28.34;  author p4;  state Exp;
branches ;
next     1.222025;

1.222025
date     2020.12.17.12.41.53;  author p4;  state Exp;
branches ;
next     1.221921;

1.221921
date     2020.12.17.11.06.13;  author p4;  state Exp;
branches ;
next     1.221886;

1.221886
date     2020.12.17.10.21.24;  author p4;  state Exp;
branches ;
next     1.220586;

1.220586
date     2020.12.15.12.56.33;  author p4;  state Exp;
branches ;
next     1.219891;

1.219891
date     2020.12.11.17.02.15;  author p4;  state Exp;
branches ;
next     1.219624;

1.219624
date     2020.12.10.16.35.37;  author p4;  state Exp;
branches ;
next     1.219071;

1.219071
date     2020.12.09.15.20.25;  author p4;  state Exp;
branches ;
next     1.218625;

1.218625
date     2020.12.08.15.34.08;  author p4;  state Exp;
branches ;
next     1.218287;

1.218287
date     2020.12.07.17.17.07;  author p4;  state Exp;
branches ;
next     1.217528;

1.217528
date     2020.12.03.16.43.18;  author p4;  state Exp;
branches ;
next     1.216991;

1.216991
date     2020.12.02.16.52.20;  author p4;  state Exp;
branches ;
next     1.216917;

1.216917
date     2020.12.02.15.58.06;  author p4;  state Exp;
branches ;
next     ;


desc
@@


1.231139
log
@@
text
@#include "precomp.h"

renderer::renderer()
{
    SDL_Init(SDL_INIT_VIDEO);
    m_p_wMainWindow = SDL_CreateWindow("Raytracer", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCRWIDTH, SCRHEIGHT, SDL_WINDOW_SHOWN);
    m_p_reMainRenderer = SDL_CreateRenderer(m_p_wMainWindow, -1, SDL_RENDERER_ACCELERATED);
    m_p_tMainTexture = SDL_CreateTexture(m_p_reMainRenderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, SCRWIDTH, SCRHEIGHT);
    m_p_cMainCamera = new camera{};

	m_p_AllScenes[0] = new testscene{};
	m_p_scActiveScene = m_p_AllScenes[0];
	iSceneCounter = 1;

	ConstructGrid();
}

renderer::~renderer()
{
	delete[] m_p_AllScenes;
	delete[] m_p_cScreenCells;
    SDL_DestroyTexture(m_p_tMainTexture);
    SDL_DestroyWindow(m_p_wMainWindow);
    SDL_DestroyRenderer(m_p_reMainRenderer);
}

void renderer::Update()
{
	// The way to access the pixel was taken from https://gigi.nullneuron.net/gigilabs/sdl2-pixel-drawing/  
	// because it was the least complex way of coloring single pixels I could find
	
	#pragma omp parallel for
	for (int y = m_iCurrentInterlace; y < SCRHEIGHT; y += m_iInterlaceStride)
	{
		
		for (int x = 0; x < SCRWIDTH; x++)
		{
			// Creating primary ray
			ray rPrimaryRay = m_p_cMainCamera->CreateRay((static_cast<float>(x) / (SCRWIDTH - 1)),
			                                                   (static_cast<float>(y) / (SCRHEIGHT - 1)));
			rPrimaryRay.iPixelX = x;
			rPrimaryRay.iPixelY = y;

			// Tracing primary ray to get the pixels color. Since all my colors are float values 
			// between 0-1 I convert them to int with a range of 0-255. Doing this only once also
			// results in me only clamping the values once
			const rgbColor rgbTempColor(Trace(rPrimaryRay, 5));

			// This is taken from Jacco Bikkers "Hitting the ground running lecture"
			m_piPixels[y * SCRWIDTH + x] = rgbTempColor.b + (rgbTempColor.g << 8) + (rgbTempColor.r << 16);

		}
	}

	// increment stride so that interlacing renders next part of screen
	m_iCurrentInterlace++;
	m_iCurrentInterlace %= m_iInterlaceStride;
	
	// Updates the texture with the pixels array 
	SDL_UpdateTexture(m_p_tMainTexture, nullptr, m_piPixels, (SCRWIDTH * sizeof(Uint32)));
	
	// Rendering created texture to screen
	SDL_RenderCopy(m_p_reMainRenderer, m_p_tMainTexture, nullptr, nullptr);
	SDL_RenderPresent(m_p_reMainRenderer);
}


void renderer::CheckForPrimaryIntersections(ray& rAPrimaryRay, intersectionData& isdIntersectionData) const
{
	int iPixelX = rAPrimaryRay.iPixelX;
	int iPixelY = rAPrimaryRay.iPixelY;

	// calculating which cell the current pixel is in
	int iCellX = iPixelX / m_fCW;
	int iCellY = iPixelY / m_fCH;

	if (iCellX == 0 && iCellY == 0)
	{
		int k = 7;
	}
	
	// get current cells primitive counters
	int iPrimitiveCounter = m_p_cScreenCells[iCellX + iCellY * CELLAMOUNT_WIDTH].m_iPrimCounter;

	for (int i = 0; i < iPrimitiveCounter; i++)
	{
		int iPrimitiveIndex = m_p_cScreenCells[iCellX + iCellY * CELLAMOUNT_WIDTH].m_iPrimitiveIndices[i];

		const float fTempDistance = rAPrimaryRay.m_fDistance;

		if (m_p_scActiveScene->m_prPrimitives[iPrimitiveIndex]->RayIntersection(rAPrimaryRay, isdIntersectionData)
			&& (rAPrimaryRay.m_fDistance < fTempDistance))
		{

			rAPrimaryRay.m_iNearestPrimitiveIndex = i;

		}
	}
}

void renderer::CheckForIntersection(ray& rARay, intersectionData& isdIntersectionData) const
{
	// Gets the current scenes primitive counter
	const int iObjectCounter = m_p_scActiveScene->m_iPrimitiveCounter;

	// Iterates over all primitives in the active scene and checks if
	// ray intersects with them

		for (int i = 0; i < iObjectCounter; i++)
		{
			const float fTempDistance = rARay.m_fDistance;

			if (m_p_scActiveScene->m_prPrimitives[i]->RayIntersection(rARay, isdIntersectionData)
				&& (rARay.m_fDistance < fTempDistance))
			{

				rARay.m_iNearestPrimitiveIndex = i;

			}
		}
}

ray& renderer::CastShadowRay(vec3& aOrigin, vec3& aLightPosition, vec3 aCollideNormal, intersectionData& isdIntersectionData) const
{
    vec3 v3Direction = aLightPosition - aOrigin;
    ray rShadowRay{};

	// If IntersectionNormal.DotWith(vector towards light) < 0, then light source is 
	// behind th object the ray intersected with -> do not send out shadow ray
	
    if (aCollideNormal.DotWith(v3Direction) < 0)
    {
        isdIntersectionData.m_bIntersectionDetected = true;
        return rShadowRay;
    }

	// Send out shadow ray and check for intersection
	rShadowRay = {aOrigin + aCollideNormal * 0.0001f, v3Direction};

    CheckForIntersection(rShadowRay, isdIntersectionData);

    return rShadowRay;
}

vec3 renderer::CalculateShadows(intersectionData& isdData)
{
	vec3 v3Origin = isdData.m_v3IntersectionPoint + isdData.m_v3IntersectionNormal * 0.0001;
	
	// Cast shadow rays
	ray rShadowRay = CastShadowRay(v3Origin, m_p_scActiveScene->m_lsLight.m_v3Position, isdData.m_v3IntersectionNormal, isdData);


	bool bOccluded = isdData.m_bIntersectionDetected;
	return CalculateDiffuseColor(bOccluded, rShadowRay, m_p_scActiveScene->m_lsLight, isdData.m_v3IntersectionNormal, isdData.m_maTransportedMaterial);
}

vec3 renderer::CalculateDiffuseColor(bool bShadowRayOccluded, ray& aShadowRay, lightSource& lsALightSource, vec3& v3AIntersectionNormal, material& maObjectMaterial) const
{	
    if (bShadowRayOccluded) return {};

    //TODO rename LightStrength to distanceAttenuation && add diffuse shading
    // Calculate distance attenuation by dividing 1 by the length of the vector
    // between the light source and the shadow rays origin squared
    const vec3 v3VecToLight = lsALightSource.m_v3Position - aShadowRay.m_v3Origin;
    const float fTempDistanceToLight = v3VecToLight.GetSquaredMagnitude();
    const float fLightStrength = 1.0f / (fTempDistanceToLight);
   
    const float fDiffusion = maObjectMaterial.fDiffusion;
	
    // Calculating illumination by factoring in the angle of the light hitting the
    // object & multiplying that with the diffusion of the material
    float fIllumination = aShadowRay.m_v3Direction.DotWith(v3AIntersectionNormal);
    mathm::Clamp(fIllumination, 1.0f, 0.0f);
    //fIllumination *= fDiffusion;

    vec3 v3LightAccumulation{};
    v3LightAccumulation += lsALightSource.m_v3LightColor * fLightStrength * fIllumination;
	
    return maObjectMaterial.m_v3Color * v3LightAccumulation;
}

float renderer::Fresnel(vec3& v3IncomingDirection, vec3& v3OutgoingDirection, vec3& v3IntersectionNormal, float n1, float n2)
{
	// calculating cos(θi) && cos(θt) 
	const float fIncomingCosine = v3IncomingDirection.DotWith(v3IntersectionNormal);
	const float fTransmittedCosine = v3OutgoingDirection.DotWith(v3IntersectionNormal);

	// calculating reflectance for s-polarized light
	float fTempA = n2 * fIncomingCosine;
	float fTempB = n1 * fTransmittedCosine;
	float fReflectanceS = (fTempA - fTempB) / (fTempA + fTempB);
	fReflectanceS *= fReflectanceS;

	// calculating reflectance for p-polarized light
	fTempA = n2 * fTransmittedCosine;
	fTempB = n1 * fIncomingCosine;
	float fReflectanceP = (fTempA - fTempB) / (fTempA + fTempB);
	fReflectanceP *= fReflectanceP;

	// returning reflectance for unpolarized light
	return (fReflectanceS + fReflectanceP) * 0.5f;
}

vec3 renderer::Trace(ray rPrimaryRay, int iRecursionCap)
{
	
#ifdef _DEBUG

	//test for refraction function, result should be (2.6674, -2.76958, 0)
	vec3 normal{ 0,1,0 };
	vec3 direction{ 4,-4,0 };

	vec3 test = RefractRay(direction, normal, 1.5, 1.000293);
#endif

	
	if (iRecursionCap > 0)
	{
		iRecursionCap--;

		// interseting primary ray with primitives in a scene
		intersectionData isdTempData;

		if (!rPrimaryRay.bIsPrimaryRay)
		{
			isdTempData = m_p_scActiveScene->GetIntersection(rPrimaryRay);
		}
		else CheckForPrimaryIntersections(rPrimaryRay, isdTempData);
		//isdTempData = m_p_scActiveScene->GetIntersection(rPrimaryRay);


		// assigning frequently used 
		float fReflectionIndex = isdTempData.m_maTransportedMaterial.m_fReflectionIndex;
		float fRefractionIndex = isdTempData.m_maTransportedMaterial.m_fRefractionIndex;

		vec3 v3IntersectionNormal = isdTempData.m_v3IntersectionNormal;
		vec3 v3Origin = isdTempData.m_v3IntersectionPoint + isdTempData.m_v3IntersectionNormal * 0.0001;

		vec3 v3Direction = rPrimaryRay.m_v3Direction;

		//TODO abstract if statements, put things inside in its own function
		if (fReflectionIndex == 0)
		{
			// calculating shadows
			return CalculateShadows(isdTempData);
			
		}
		else if (fReflectionIndex == 1)
		{
			// calculating total reflection
			ray rSecondaryRay = { v3Origin, ReflectRay(v3Direction, v3IntersectionNormal) };
			return Trace(rSecondaryRay, iRecursionCap);

		}
		else if (fReflectionIndex > 0 && fReflectionIndex < 1)
		{

			// constructing secondary ray && Tracing Reflected ray
			ray rSecondaryRay = { v3Origin, ReflectRay(v3Direction, v3IntersectionNormal) };
			vec3 v3TempColor = isdTempData.m_maTransportedMaterial.m_v3Color;

			vec3 v3ReflectedColor = Trace(rSecondaryRay, iRecursionCap) * fReflectionIndex;

			// calculating shadows & shadow color
			vec3 v3ShadowRayColor = CalculateShadows(isdTempData);
			v3ShadowRayColor *= v3TempColor * (1 - fReflectionIndex);

			return (v3ReflectedColor + v3ShadowRayColor);
			
		} else if (fRefractionIndex >= 1)
		{
			
			// this approach to refraction was taken from Jacco Bikkers 5th Lecture
			float fN1 = rPrimaryRay.m_fCurrentRefractionIndex;
			float fN2 = isdTempData.m_maTransportedMaterial.m_fRefractionIndex;


			// TODO resolve
			// this will cause an issue if there is a glass sphere in another glass sphere

			// if the current medium the ray is in is not air, make the medium he is leaving
			// into to air
			if (fN1 > 1.10f && rPrimaryRay.m_bInPrimitive)
			{
				fN2 = 1.10f;
			}

			// calculating refracted ray origin offset
			vec3 v3RefractedOrigin = isdTempData.m_v3IntersectionPoint - isdTempData.m_v3IntersectionNormal * 0.001f;

			// refract primary ray & constructing refracted ray
			vec3 v3RefractedDirection = RefractRay(v3Direction, v3IntersectionNormal, fN2, fN1);
			ray rRefractedRay{v3RefractedOrigin, v3RefractedDirection};

			// calculating reflectance of unpolarized light
			float fReflectance = Fresnel(v3Direction, v3RefractedDirection, 
											v3IntersectionNormal ,fN1, fN2);

			// calculating color of refracted ray
			vec3& v3MaterialColor = isdTempData.m_maTransportedMaterial.m_v3Color;
			vec3 v3RefractionColor = Trace(rRefractedRay, iRecursionCap) * (1 - fReflectance) * v3MaterialColor;

			
			// reflecting primary ray & constructing secondary ray
			vec3 v3SecondaryDirection = ReflectRay(v3Direction, v3IntersectionNormal);
			ray rSecondaryRay{v3Origin, v3SecondaryDirection};

			// calculating reflection color
			vec3 v3ReflectionColor = Trace(rSecondaryRay, iRecursionCap) * fReflectance;

			// returning color
			return v3ReflectionColor + v3RefractionColor;
			
		}
	}
	else return {};
}

vec3 renderer::ReflectRay(vec3& v3Direction, vec3& v3IntersectionNormal)
{
	//the idea for this function was taken from Jacco Bikker's 4th lecture
	// Returns the new direction of a reflected vector
	return { v3Direction - v3IntersectionNormal * (v3Direction.DotWith(v3IntersectionNormal)) * 2 };
}

vec3 renderer::RefractRay(vec3& v3Direction, vec3& v3IntersectionNormal, float fInsideRefraction, float fOutsideRefraction)
{
	// n1 == refractionIndex of the outside medium
	// n2 == refractionIndex of the inside medium
	const float n1 = fOutsideRefraction;
	const float n2 = fInsideRefraction;

	const float j = (n1 / n2);

	// calculating the cosine of the angle between the rays direction & the normal
	// of the intersection point by dotting the Normal with -(Direction)
	vec3 v3InverseDirection = v3Direction * (-1.0);
	const float cosTheta = v3IntersectionNormal.DotWith(v3InverseDirection);

	const float k = 1.0 - ((j * j) * (1 - cosTheta * cosTheta));
	
	// through Snell's Law, we know that if k < 0, there is no refraction occurring, only 
	// reflection (because of total internal reflection) return reflectRay()
	if (k < 0)
	{
		return ReflectRay(v3Direction, v3IntersectionNormal);
	}
	
	// if k >= 0, refraction occurs -> calculate T (transmitted vector)
	// and return it
	return {v3Direction * j + v3IntersectionNormal * (j * cosTheta - sqrt(k)) };
}

void renderer::ConstructGrid()
{
	// loop over all of the primitives
	//		if they are spheres && not behind the camera
	//				get their radius && center point
	//				calculate the corners of the bounding box they occupy
	//				calculate which cells they occupy
	//				for each cell they occupy, update the primitive index array && the primitive counter
	// 

	int iCounter = m_p_scActiveScene->m_iPrimitiveCounter;
	
	for (int i = 0; i < iCounter; i++)
	{
		// if the primitive is a sphere
		if (m_p_scActiveScene->m_prPrimitives[i]->m_iPrimitiveType == 2)
		{
			primitive* p_prCurrentPrimitive = m_p_scActiveScene->m_prPrimitives[i];
			float fRadiusInPixels = 0;
			float ViewPortWidth = (m_p_cMainCamera->m_v3ViewportP1 - m_p_cMainCamera->m_v3ViewportP0).GetMagnitude();
			vec3 v3OnScreenPos = m_p_scActiveScene->m_prPrimitives[i]->GetScreenspaceCoordinate(
				m_p_cMainCamera->m_v3Position, m_p_cMainCamera->m_v3ViewportP0, m_p_cMainCamera->m_v3ViewportP1,
				m_p_cMainCamera->m_v3ViewportP0, m_p_cMainCamera->m_v3ViewportP2, SCRWIDTH, SCRHEIGHT, ViewPortWidth, fRadiusInPixels);

			float fMinX = v3OnScreenPos.x - fRadiusInPixels;
			float fMaxX = v3OnScreenPos.x + fRadiusInPixels;

			float fMinY = v3OnScreenPos.y - fRadiusInPixels;
			float fMaxY = v3OnScreenPos.y + fRadiusInPixels;

			// calculate 
			int iMaxCellX = fMaxX / m_fCW;
			int iMaxCellY = fMaxY / m_fCH;

			int iMinCellX = fMinX / m_fCW;
			int iMinCellY = fMinY / m_fCH;

			mathm::Clamp(iMinCellX, CELLAMOUNT_WIDTH, 0);
			mathm::Clamp(iMinCellY, CELLAMOUNT_HEIGHT, 0);
			mathm::Clamp(iMaxCellX, CELLAMOUNT_WIDTH, 0);
			mathm::Clamp(iMaxCellY, CELLAMOUNT_HEIGHT, 0);

			for (int j = iMinCellX; j <= iMaxCellX; j++)
			{
				for (int k = iMinCellY; k <= iMaxCellY; k++)
				{

					int& iIndex = m_p_cScreenCells[j + k * CELLAMOUNT_WIDTH].m_iPrimCounter;
					m_p_cScreenCells[j + k * CELLAMOUNT_WIDTH].m_iPrimitiveIndices[iIndex] = i;
					iIndex++;
				}
			}
		} else if (m_p_scActiveScene->m_prPrimitives[i]->m_iPrimitiveType == 1)
		{
			for (int j = 0; j < CELLAMOUNT_WIDTH * CELLAMOUNT_HEIGHT; j++)
			{
				m_p_cScreenCells[j].m_iPrimCounter++;
				m_p_cScreenCells[j].m_iPrimitiveIndices[m_p_cScreenCells[j].m_iPrimCounter] = i;
			}
		}
	}
	//m_p_cScreenCells[5 + 7 * CELLAMOUNT_WIDTH].m_iPrimCounter = 0;
}
@


1.230304
log
@@
text
@d35 1
a35 1
		//unsigned int* row = pixels + y * SCRWIDTH; //this optimization was shamelessly stolen from Professor Jacco Bikker
d74 7
a80 2
	int iCellX = iPixelX * m_fCW;
	int iCellY = iPixelY * m_fCH;
d82 1
a82 1
	// get current cells primitive counter
d229 1
d283 1
a283 1
			/*if (fN1 > 1.10f && rPrimaryRay.m_bInPrimitive)
d286 1
a286 1
			}*/
d385 2
a386 2
			int iMaxCellX = fMaxX * m_fCW;
			int iMaxCellY = fMaxY * m_fCH;
d388 2
a389 2
			int iMinCellX = fMinX * m_fCW;
			int iMinCellY = fMinY * m_fCH;
d411 1
a411 1
				m_p_cScreenCells[j].m_iPrimitiveIndices[m_p_cScreenCells[j].m_iPrimCounter++] = i;
d415 1
@


1.229956
log
@@
text
@d14 2
d31 2
a32 1
#pragma omp parallel for
d39 1
a39 1
			const ray rPrimaryRay = m_p_cMainCamera->CreateRay((static_cast<float>(x) / (SCRWIDTH - 1)),
d41 2
a51 12
#ifdef _DEBUG
			// Testing whether or not the GetScreenspaceCoordinate function returns center point
			// of sphere
			float fRadiusInPixels = 0;
			float ViewPortWidth = (m_p_cMainCamera->m_v3ViewportP1 - m_p_cMainCamera->m_v3ViewportP0).GetMagnitude();
			vec3 testPos = m_p_scActiveScene->m_prPrimitives[1]->GetScreenspaceCoordinate(
				m_p_cMainCamera->m_v3Position, m_p_cMainCamera->m_v3ViewportP0, m_p_cMainCamera->m_v3ViewportP1,
				m_p_cMainCamera->m_v3ViewportP0, m_p_cMainCamera->m_v3ViewportP2, SCRWIDTH, SCRHEIGHT, ViewPortWidth, fRadiusInPixels);
			
			m_piPixels[(int)(testPos.y) * SCRWIDTH + (int)(testPos.x)] = 255 + (0 << 8) + (255 << 16);
#endif

d68 28
a102 3
    for (int i = 0; i < iObjectCounter; i++)
    {
	    const float fTempDistance = rARay.m_fDistance;
d104 3
a106 3
        if (m_p_scActiveScene->m_prPrimitives[i]->RayIntersection(rARay, isdIntersectionData)
            && (rARay.m_fDistance < fTempDistance))
        {
d108 3
a110 1
            rARay.m_iNearestPrimitiveIndex = i;
d112 4
a115 2
        }
    }
d217 8
a224 1
		intersectionData isdTempData = m_p_scActiveScene->GetIntersection(rPrimaryRay);
d277 1
a277 1
			/*if (fN1 < 1.10f && rPrimaryRay.m_bInPrimitive)
d358 13
a370 1
	//int iCounter = m_p_scActiveScene->m_iPrimitiveCounter;
d372 2
a373 14
	//float fCW = SCRWIDTH / CELLAMOUNT_WIDTH;
	//float fCH = SCRHEIGHT / CELLAMOUNT_HEIGHT;
	//
	//for (int i = 0; i < iCounter; i++)
	//{
	//	// if the primitive is a sphere
	//	if (m_p_scActiveScene->m_prPrimitives[i]->m_iPrimitiveType == 2)
	//	{
	//		primitive* p_prCurrentPrimitive = m_p_scActiveScene->m_prPrimitives[i];
	//		float fRadiusInPixels = 0;
	//		float ViewPortWidth = (m_p_cMainCamera->m_v3ViewportP1 - m_p_cMainCamera->m_v3ViewportP0).GetMagnitude();
	//		vec3 v3OnScreenPos = m_p_scActiveScene->m_prPrimitives[1]->GetScreenspaceCoordinate(
	//			m_p_cMainCamera->m_v3Position, m_p_cMainCamera->m_v3ViewportP0, m_p_cMainCamera->m_v3ViewportP1,
	//			m_p_cMainCamera->m_v3ViewportP0, m_p_cMainCamera->m_v3ViewportP2, SCRWIDTH, SCRHEIGHT, ViewPortWidth, fRadiusInPixels);
d375 2
a376 2
	//		float fMinX = p_prCurrentPrimitive->m_v3Position.x - fRadiusInPixels;
	//		float fMaxX = p_prCurrentPrimitive->m_v3Position.x + fRadiusInPixels;
d378 3
a380 2
	//		float fMinY = p_prCurrentPrimitive->m_v3Position.y - fRadiusInPixels;
	//		float fMaxY = p_prCurrentPrimitive->m_v3Position.y + fRadiusInPixels;
d382 27
a408 3
	//		
	//	}
	//}
@


1.228854
log
@@
text
@d19 1
a28 1
	
d46 13
d318 38
@


1.228236
log
@@
text
@d164 1
a164 1
vec3 renderer::Trace(ray rPrimaryRay, int iReflectionAmount)
d177 1
a177 1
	if (iReflectionAmount > 0)
d179 1
a179 1
		iReflectionAmount--;
d204 1
a204 1
			return Trace(rSecondaryRay, iReflectionAmount);
d214 1
a214 1
			vec3 v3ReflectedColor = Trace(rSecondaryRay, iReflectionAmount) * fReflectionIndex;
d226 2
a227 2
			float fN1 = 0.1f;//rPrimaryRay.m_fCurrentRefractionIndex;
			float fN2 = 0.5f;// isdTempData.m_maTransportedMaterial.m_fRefractionIndex;
d235 1
a235 1
			if (mathm::CompFloat(fN1, fN2))
d237 2
a238 2
				mathm::Swap(fN1, fN2);
			}
a245 1
			rRefractedRay.m_fCurrentRefractionIndex = fN2;
d253 1
a253 1
			vec3 v3RefractionColor = Trace(rRefractedRay, iReflectionAmount) * (1 - fReflectance) * v3MaterialColor;
d261 1
a261 1
			vec3 v3ReflectionColor = Trace(rSecondaryRay, iReflectionAmount) * fReflectance;
d264 1
a264 1
			return /*v3ReflectionColor +*/ v3RefractionColor;
@


1.228098
log
@@
text
@d28 3
a30 1
	for (int y = 0; y < SCRHEIGHT; y++)
d45 1
a45 1
			pixels[y * SCRWIDTH + x] = rgbTempColor.b + (rgbTempColor.g << 8) + (rgbTempColor.r << 16);
d49 4
d54 1
a54 1
	SDL_UpdateTexture(m_p_tMainTexture, nullptr, pixels, (SCRWIDTH * sizeof(Uint32)));
d142 1
a142 1
float renderer::Fresnel(vec3& v3IncomingDirection, vec3& v3OutgoingDirection, vec3 v3IntersectionNormal, float n1, float n2)
a165 1
	// TODO refactor. urgent!!!
a176 1
	
d180 2
a181 1
		
d183 5
d191 2
d194 1
a194 1
		if (isdTempData.m_maTransportedMaterial.m_fReflectionIndex == 0)
d196 1
a196 7
			//// Cast shadow rays
			//ray rShadowRay = CastShadowRay(v3Origin, m_p_scActiveScene->m_lsLight.m_v3Position, v3IntersectionNormal, isdTempData);


			//bool bOccluded = isdTempData.m_bIntersectionDetected;
			//return CalculateDiffuseColor(bOccluded, rShadowRay, m_p_scActiveScene->m_lsLight, isdTempData.m_v3IntersectionNormal, isdTempData.m_maTransportedMaterial);

d200 1
a200 1
		else if (isdTempData.m_maTransportedMaterial.m_fReflectionIndex == 1)
d202 1
a202 2
			vec3 v3Direction = rPrimaryRay.m_v3Direction;

d204 1
a204 2
			vec3 v3TempColor = isdTempData.m_maTransportedMaterial.m_v3Color;
			return  /*v3TempColor **/ Trace(rSecondaryRay, iReflectionAmount);
d207 1
a207 2
		else if (isdTempData.m_maTransportedMaterial.m_fReflectionIndex > 0
			&& isdTempData.m_maTransportedMaterial.m_fReflectionIndex < 1)
d210 1
a210 2
			//constructing secondary ray
			vec3 v3Direction = rPrimaryRay.m_v3Direction;
d214 1
a214 8
			vec3 v3ReflectedColor = Trace(rSecondaryRay, iReflectionAmount) * isdTempData.m_maTransportedMaterial.m_fReflectionIndex;

			//// Cast shadow rays
			//ray rShadowRay = CastShadowRay(v3Origin, m_p_scActiveScene->m_lsLight.m_v3Position, v3IntersectionNormal, isdTempData);
			//bool bOccluded = isdTempData.m_bIntersectionDetected;

			vec3 v3ShadowRayColor = CalculateShadows(isdTempData);/*CalculateDiffuseColor(bOccluded, rShadowRay, m_p_scActiveScene->m_lsLight, isdTempData.m_v3IntersectionNormal,
				isdTempData.m_maTransportedMaterial);*/
d216 3
a218 1
			v3ShadowRayColor *= v3TempColor * (1 - isdTempData.m_maTransportedMaterial.m_fReflectionIndex);
d222 1
a222 1
		} else if (isdTempData.m_maTransportedMaterial.m_fRefractionIndex >= 1)
a223 1
			// TODO
d244 1
a244 1
			vec3 v3RefractedDirection = RefractRay(rPrimaryRay.m_v3Direction, v3IntersectionNormal, fN2, fN1);
d249 2
a250 1
			float fReflectance = Fresnel(rPrimaryRay.m_v3Direction, v3RefractedDirection,v3IntersectionNormal ,fN1, fN2);
d254 1
a254 1
			vec3 v3RefractionColor = Trace(rRefractedRay, iReflectionAmount) * (1 - fReflectance) /** v3MaterialColor*/;
d258 1
a258 1
			vec3 v3SecondaryDirection = ReflectRay(rPrimaryRay.m_v3Direction, v3IntersectionNormal);
d295 2
a296 2
	// through Snell's Law, we know that if k < 0, there is no refraction occurring, only reflection
	// (because of total internal reflection) return reflectRay()
@


1.225070
log
@@
text
@d11 1
a11 1
	m_p_AllScenes[0] = new scene{};
d34 2
a35 2
			ray rPrimaryRay = m_p_cMainCamera->CreateRay((static_cast<float>(x) / (SCRWIDTH - 1)),
			                                             (static_cast<float>(y) / (SCRHEIGHT - 1)));
d56 1
a56 1
void renderer::CheckForIntersection(ray& rARay, intersectionData& isdIntersectionData)
d59 1
a59 1
	int iObjectCounter = m_p_scActiveScene->m_iPrimitiveCounter;
d77 1
a77 1
ray& renderer::CastShadowRay(vec3& aOrigin, vec3& aLightPosition, vec3 aCollideNormal, intersectionData& isdIntersectionData)
d99 13
a111 1
vec3 renderer::CalculatePixelColor(bool bShadowRayOccluded, ray& aShadowRay, lightSource& lsALightSource, vec3& v3AIntersectionNormal, material& maObjectMaterial) const
d139 2
a140 2
	float fIncomingCosine = v3IntersectionNormal.DotWith(v3IncomingDirection);
	float fTransmittedCosine = v3IntersectionNormal.DotWith(v3OutgoingDirection);
d143 2
a144 2
	float fTempA = n1 * fIncomingCosine;
	float fTempB = n2 * fTransmittedCosine;
d149 2
a150 2
	fTempA = n1 * fTransmittedCosine;
	fTempB = n2 * fIncomingCosine;
d155 1
a155 1
	return fReflectanceS + fReflectanceP;
d184 2
a185 2
			// Cast shadow rays
			ray rShadowRay = CastShadowRay(v3Origin, m_p_scActiveScene->lsPointLight.m_v3Position, v3IntersectionNormal, isdTempData);
d188 2
a189 2
			bool bOccluded = isdTempData.m_bIntersectionDetected;
			return CalculatePixelColor(bOccluded, rShadowRay, m_p_scActiveScene->lsPointLight, isdTempData.m_v3IntersectionNormal, isdTempData.m_maTransportedMaterial);
d191 2
d212 1
a212 1
			vec3 v3ReflectedColor = Trace(rSecondaryRay, iReflectionAmount) * isdTempData.m_maTransportedMaterial.m_fReflectionIndex /** v3TempColor*/;
d214 3
a216 3
			// Cast shadow rays
			ray rShadowRay = CastShadowRay(v3Origin, m_p_scActiveScene->lsPointLight.m_v3Position, v3IntersectionNormal, isdTempData);
			bool bOccluded = isdTempData.m_bIntersectionDetected;
d218 2
a219 2
			vec3 v3ShadowRayColor = CalculatePixelColor(bOccluded, rShadowRay, m_p_scActiveScene->lsPointLight, isdTempData.m_v3IntersectionNormal,
				isdTempData.m_maTransportedMaterial);
d230 2
a231 2
			float fN1 = rPrimaryRay.m_fCurrentRefractionIndex;
			float fN2 = isdTempData.m_maTransportedMaterial.m_fRefractionIndex;
d239 1
a239 1
			if (fN1 != 1.100f)
d241 1
a241 1
				fN2 = 1.100f;
d245 1
a245 1
			vec3 v3RefractedOrigin = isdTempData.m_v3IntersectionPoint - isdTempData.m_v3IntersectionNormal * 0.0001;
d257 1
a257 1
			vec3 v3RefractionColor = Trace(rRefractedRay, iReflectionAmount) * (1 - fReflectance) * v3MaterialColor;
d268 1
a268 1
			return v3ReflectionColor + v3RefractionColor;
d286 2
a287 4
	float n1 = fOutsideRefraction;
	float n2 = fInsideRefraction;
	
	float j = (n1 / n2);
d289 2
d294 1
a294 1
	float theta = v3IntersectionNormal.DotWith(v3InverseDirection);
d296 1
a296 1
	float k = 1.0 - ((j * j) * (1 - theta * theta));
d307 1
a307 1
	return {v3Direction * j + v3IntersectionNormal *(j * theta - sqrt(k)) };
@


1.225059
log
@@
text
@d213 43
a255 1
			// TODO add refractions
@


1.223997
log
@@
text
@d26 2
a27 5
	//TODO add HDR skydome
	SDL_UpdateTexture(m_p_tMainTexture, nullptr, pixels, (SCRWIDTH * sizeof(Uint32)));

	// The way to access the pixel was taken from https://gigi.nullneuron.net/gigilabs/sdl2-pixel-drawing/ because it was the least complex way of 
	// coloring single pixels I could find
d47 3
d103 1
a103 1
    //TODO rename LightStrength to distanceAttenuation
d116 1
a116 1
    fIllumination *= fDiffusion;
d124 22
d148 2
d210 4
d228 2
a229 2
	//n1 == refractionIndex of the outside medium
	//n2 == refractionIndex of the inside medium
d235 2
a236 2
	//calculating the cosine of the angle between the rays direction & the normal
	//of the intersection point by dotting the Normal with -(Direction)
d242 2
a243 2
	//through Snell's Law, we know that if k < 0, there is no refraction occurring, only reflection
	//return reflectRay()
d249 1
a249 1
	//if k >= 0, refraction occurs -> calculate T (transmitted vector)
@


1.223122
log
@@
text
@d43 1
a43 1
			const rgbColor rgbTempColor(Trace(rPrimaryRay));
d124 1
a124 1
vec3 renderer::Trace(ray rPrimaryRay)
d126 1
a126 3
	intersectionData isdTempData = m_p_scActiveScene->GetIntersection(rPrimaryRay);
	vec3 v3IntersectionNormal = isdTempData.m_v3IntersectionNormal;
	vec3 v3Origin = isdTempData.m_v3IntersectionPoint + isdTempData.m_v3IntersectionNormal * 0.0001;
d128 3
a130 5
	//TODO abstract if statements, put things inside in its own function
	if (isdTempData.m_maTransportedMaterial.m_fReflectionIndex == 0)
	{
		// Cast shadow rays
		ray rShadowRay = CastShadowRay(v3Origin, m_p_scActiveScene->lsPointLight.m_v3Position, v3IntersectionNormal, isdTempData);
d132 2
d135 3
a137 4
		bool bOccluded = isdTempData.m_bIntersectionDetected;
		return CalculatePixelColor(bOccluded, rShadowRay, m_p_scActiveScene->lsPointLight, isdTempData.m_v3IntersectionNormal, isdTempData.m_maTransportedMaterial);
		
	} else if (isdTempData.m_maTransportedMaterial.m_fReflectionIndex == 1)
d139 1
a139 5
		vec3 v3Direction = rPrimaryRay.m_v3Direction;
		
		ray rSecondaryRay = {v3Origin, ReflectRay(v3Direction, v3IntersectionNormal) };
		vec3 v3TempColor = isdTempData.m_maTransportedMaterial.m_v3Color;
		return  v3TempColor * Trace(rSecondaryRay);
d141 3
a143 3
	} else if (		isdTempData.m_maTransportedMaterial.m_fReflectionIndex > 0 
				&&	isdTempData.m_maTransportedMaterial.m_fReflectionIndex < 1)
	{
d145 5
a149 4
		//constructing secondary ray
		vec3 v3Direction = rPrimaryRay.m_v3Direction;
		ray rSecondaryRay = { v3Origin, ReflectRay(v3Direction, v3IntersectionNormal) };
		vec3 v3TempColor = isdTempData.m_maTransportedMaterial.m_v3Color;
a150 1
		vec3 v3ReflectedColor = Trace(rSecondaryRay) * isdTempData.m_maTransportedMaterial.m_fReflectionIndex * v3TempColor;
d152 2
a153 3
		// Cast shadow rays
		ray rShadowRay = CastShadowRay(v3Origin, m_p_scActiveScene->lsPointLight.m_v3Position, v3IntersectionNormal, isdTempData);
		bool bOccluded = isdTempData.m_bIntersectionDetected;
d155 32
a186 6
		vec3 v3ShadowRayColor = CalculatePixelColor(bOccluded, rShadowRay, m_p_scActiveScene->lsPointLight, isdTempData.m_v3IntersectionNormal, 
													isdTempData.m_maTransportedMaterial);
		
		v3ShadowRayColor *= v3TempColor * (1 - isdTempData.m_maTransportedMaterial.m_fReflectionIndex);
		
		return (v3ReflectedColor + v3ShadowRayColor);
d188 1
d197 28
@


1.222449
log
@@
text
@d26 1
d127 2
d130 1
d134 1
a134 3
		vec3 v3Origin = isdTempData.m_v3IntersectionPoint + isdTempData.m_v3IntersectionNormal * 0.0001;
		vec3 v3CollideNormal = isdTempData.m_v3IntersectionNormal;
		ray rShadowRay = CastShadowRay(v3Origin, m_p_scActiveScene->lsPointLight.m_v3Position, v3CollideNormal, isdTempData);
a142 4
		vec3 v3IntersectionNormal = isdTempData.m_v3IntersectionNormal;

		// Offsetting the secondary rays origin by epsilon
		vec3 v3Origin = isdTempData.m_v3IntersectionPoint + isdTempData.m_v3IntersectionNormal * 0.0001;
d147 22
d174 1
@


1.222434
log
@@
text
@d98 1
a98 1
vec3 renderer::CalculatePixelColor(bool bShadowRayOccluded, ray& aShadowRay, lightSource& lsALightSource, vec3& v3AIntersectionNormal, vec3& v3ObjectColor) const
d108 2
a109 4
    

    //TODO diffusion is still hardcoded, should be part of a material
    const float fDiffusion = 0.9f;
d120 1
a120 1
    return v3ObjectColor * v3LightAccumulation;
d136 1
a136 1
		return CalculatePixelColor(bOccluded, rShadowRay, m_p_scActiveScene->lsPointLight, isdTempData.m_v3IntersectionNormal, isdTempData.m_maTransportedMaterial.m_v3Color);
@


1.222417
log
@@
text
@d28 2
a29 2
	//the way to access the pixel was taken from https://gigi.nullneuron.net/gigilabs/sdl2-pixel-drawing/ because it was the least complex way of 
	//coloring single pixels I could find
d35 1
a35 2
			intersectionData isdPrimaryIntersections{};
			intersectionData isdShadowRayIntersections{};
a37 37
			ray rShadowRay{vec3{}, vec3{}};

			//iterate over all objects & determine closest intersection (if any)
			CheckForIntersection(rPrimaryRay, isdPrimaryIntersections);

			//TODO refactor, this needs to be its own function
			//if there was an intersection with a primitive, send out shadow rays
			vec3 v3IntersectionNormal = isdPrimaryIntersections.m_v3IntersectionNormal;
			if (isdPrimaryIntersections.m_bIntersectionDetected)
			{
				const int iIndex = rPrimaryRay.m_iNearestPrimitiveIndex;
				vec3 v3LightPosition = m_p_scActiveScene->lsPointLight.m_v3Position;

				if (m_p_scActiveScene->m_prPrimitives[iIndex]->m_maObjectMaterial.m_fReflectionIndex == 0)
				{
					
					rShadowRay = CastShadowRay(isdPrimaryIntersections.m_v3IntersectionPoint, v3LightPosition,
						v3IntersectionNormal, isdShadowRayIntersections);
				} else if (m_p_scActiveScene->m_prPrimitives[iIndex]->m_maObjectMaterial.m_fReflectionIndex == 1)
				{

					vec3 v3Origin = isdPrimaryIntersections.m_v3IntersectionPoint + isdPrimaryIntersections.m_v3IntersectionNormal * 0.0001;

					vec3 v3EntryDirection = rPrimaryRay.m_v3Direction;
					vec3 v3Direction = rPrimaryRay.m_v3Direction - v3IntersectionNormal * (v3EntryDirection.DotWith(v3IntersectionNormal)) * 2;
					rShadowRay = {v3Origin, v3Direction};

					CheckForIntersection(rShadowRay, isdPrimaryIntersections);

					if (m_p_scActiveScene->m_prPrimitives[iIndex]->m_maObjectMaterial.m_fReflectionIndex == 0)
					{
						v3IntersectionNormal = isdPrimaryIntersections.m_v3IntersectionNormal;
						rShadowRay = CastShadowRay(isdPrimaryIntersections.m_v3IntersectionPoint, v3LightPosition,
							v3IntersectionNormal, isdShadowRayIntersections);
					}
				}
			}
d39 4
a42 8
			//calculating pixel color & converting it to RGB(255,255,255)
			vec3 v3ObjectColor = isdPrimaryIntersections.m_maTransportedMaterial.m_v3Color;
			const bool bLightOccluded = isdShadowRayIntersections.m_bIntersectionDetected;
			const vec3 v3PixelColor = CalculatePixelColor(bLightOccluded, rShadowRay, m_p_scActiveScene->lsPointLight,
			                                              v3IntersectionNormal, v3ObjectColor);

			const rgbColor rgbTempColor(v3PixelColor);

d44 1
a44 1
			//this is taken from Jacco Bikkers "Hitting the ground running lecture"
d49 1
d57 1
d59 3
a61 1
	
d81 3
a83 2
	//if IntersectionNormal.DotWith(vector towards light) < 0,
	//do not send out shadow rays, returns empty ray
d90 1
d103 2
a104 2
    //calculate distance attenuation by dividing 1 by the length of the vector
    //between the light source and the shadow rays origin squared
d113 2
a114 2
    //calculating illumination by factoring in the angle of the light hitting the
    //object & multiplying that with the diffusion of the material
d131 1
a131 1
		//cast shadow rays
d145 1
a145 1
		//offsetting the secondary rays origin by epsilon
d156 1
a156 1
	//returns the new direction of a reflected vector
@


1.222402
log
@@
text
@a27 2
	lightSource lsPointLight{vec3{5, 4, -1}, {}, {50, 50, 50}, 1};

d50 1
d54 2
a55 1
					rShadowRay = CastShadowRay(isdPrimaryIntersections.m_v3IntersectionPoint, lsPointLight.m_v3Position,
d71 1
a71 1
						rShadowRay = CastShadowRay(isdPrimaryIntersections.m_v3IntersectionPoint, lsPointLight.m_v3Position,
d78 1
a78 1
			vec3 v3ObjectColor = isdPrimaryIntersections.m_v3Color;
d80 1
a80 1
			const vec3 v3PixelColor = CalculatePixelColor(bLightOccluded, rShadowRay, lsPointLight,
d163 31
a193 1
	return vec3();
@


1.222025
log
@@
text
@d11 3
a13 2
    m_p_prPrimitives[0] = m_plTestPlane;
    m_p_prPrimitives[1] = m_spTestSphere;
d18 1
d46 1
a46 1

d48 1
a48 1
			vec3 v3IntersectionNormal{};
a51 2
				v3IntersectionNormal = m_p_prPrimitives[iIndex]->GetIntersectionNormal(
					isdPrimaryIntersections.m_v3IntersectionPoint);
d53 22
a74 2
				rShadowRay = CastShadowRay(isdPrimaryIntersections.m_v3IntersectionPoint, lsPointLight.m_v3Position,
				                           v3IntersectionNormal, isdShadowRayIntersections);
d98 3
a100 1
    for (int i = 0; i < m_iObjectCounter; i++)
d104 1
a104 1
        if (m_p_prPrimitives[i]->RayIntersection(rARay, isdIntersectionData)
d160 5
@


1.221921
log
@@
text
@d24 1
a24 1
    SDL_UpdateTexture(m_p_tMainTexture, NULL, pixels, (SCRWIDTH * sizeof(Uint32)));
d26 1
a26 1
    lightSource lsPointLight{ vec3{ 5, 4, -1 } , {}, {50,50,50}, 1 };
d28 12
a39 7
    
    //---------------------------------------------------------------------------------------------------------------------------------------------
    //the way to access the pixel was taken from https://gigi.nullneuron.net/gigilabs/sdl2-pixel-drawing/ because it was the least complex way of 
    //coloring single pixels I could find
    for (int y = 0; y < SCRHEIGHT; y++)
    {
        //unsigned int* row = pixels + y * SCRWIDTH; //this optimization was shamelessly stolen from Professor Jacco Bikker
d41 2
a42 6
        for (int x = 0; x < SCRWIDTH; x++)
        {
            vec3 v3PixelColor{};
            intersectionData isdPrimaryIntersections{};
            ray rPrimaryRay = m_p_cMainCamera->CreateRay( (static_cast<float>(x) / (SCRWIDTH - 1) ), (static_cast<float>(y) / (SCRHEIGHT - 1)) );
            ray rShadowRay{vec3{}, vec3{}};
a43 13
        	//iterate over all objects & determine closest intersection (if any)
            for (int i = 0; i < 2; i++)
            {
                float fTempDistance = rPrimaryRay.m_fDistance;
            	
                if (    m_p_prPrimitives[i]->RayIntersection(rPrimaryRay, isdPrimaryIntersections) 
					&&  (rPrimaryRay.m_fDistance < fTempDistance))
                {
					
                    rPrimaryRay.m_iNearestPrimitiveIndex = i;
                	
                }
            }
d45 7
d53 3
a55 3
            int iIndex = rPrimaryRay.m_iNearestPrimitiveIndex;
            vec3 v3IntersectionNormal{};
            bool bLightOccluded = false;
d57 5
a61 7
            if (rPrimaryRay.m_iNearestPrimitiveIndex != 404)
            {
                v3IntersectionNormal = m_p_prPrimitives[iIndex]->GetIntersectionNormal(isdPrimaryIntersections.m_v3IntersectionPoint);
            	
            	//TODO add if statement that checks if N.dotwith(L) < 0, if it is, do not send out shadow ray
                rShadowRay = castShadowRay(isdPrimaryIntersections.m_v3IntersectionPoint, lsPointLight.m_v3Position,
                    v3IntersectionNormal);
d63 1
a63 10
                //TODO rename LightStrength to distanceAttenuation
                for (int j = 0; j < 2; j++)
                {
                    if (m_p_prPrimitives[j]->RayIntersection(rShadowRay, isdPrimaryIntersections) && !bLightOccluded)
                    {
                        bLightOccluded = true;
                        break;
                    }
                }
            } 
a64 6
        	//calculating pixel color & converting it to RGB(255,255,255)
            vec3 v3ObjectColor = isdPrimaryIntersections.m_v3Color;
            v3PixelColor = CalculatePixelColor(bLightOccluded, rShadowRay, lsPointLight,
											v3IntersectionNormal, v3ObjectColor);
        	
            const rgbColor rgbTempColor(v3PixelColor);
a65 1
        	
d67 21
a87 1
            pixels[y * SCRWIDTH + x] = rgbTempColor.b + (rgbTempColor.g << 8) + (rgbTempColor.r << 16); 
a89 3

    SDL_RenderCopy(m_p_reMainRenderer, m_p_tMainTexture, NULL, NULL);
    SDL_RenderPresent(m_p_reMainRenderer);
d92 1
a92 1
ray& renderer::castShadowRay(vec3& aOrigin, vec3& aEndPoint, vec3 aCollideNormal)
d94 16
a109 4
    vec3 v3Direction = aEndPoint - aOrigin;
	ray tempRay{aOrigin + aCollideNormal * 0.0001f, v3Direction};
	
    return tempRay;
d112 1
a112 1
vec3 renderer::CalculatePixelColor(bool bShadowRayOccluded, ray& aShadowRay, lightSource& lsALightSource, vec3& v3AIntersectionNormal, vec3& v3ObjectColor)
d115 2
a116 1
    
d119 3
a121 3
    vec3 v3VecToLight = lsALightSource.m_v3Position - aShadowRay.m_v3Origin;
    float fTempDistanceToLight = v3VecToLight.GetSquaredMagnitude();
    float fLightStrength = 1.0f / (fTempDistanceToLight);
d125 1
a125 1
    float fDiffusion = 0.9f;
d129 3
a131 3
    float fIlumination = aShadowRay.m_v3Direction.DotWith(v3AIntersectionNormal);
    mathm::Clamp(fIlumination, 1.0f, 0.0f);
    fIlumination *= fDiffusion;
d134 1
a134 1
    v3LightAccumulation += lsALightSource.m_v3LightColor * fLightStrength * fIlumination;
@


1.221886
log
@@
text
@d44 1
a44 1
            for (int i = 0; i <= 1; i++)
d86 3
a88 2
            const rgbColor rgbTempColor = ConvertToRgb(v3PixelColor);
         
d106 10
a115 10
rgbColor renderer::ConvertToRgb(vec3 a_vec3Color)
{
    int r = static_cast<int>(256.0f * a_vec3Color.x);
    mathm::Clamp(r, 255, 0);

    int g = static_cast<int>(256.0f * a_vec3Color.y);
    mathm::Clamp(g, 255, 0);

    int b = static_cast<int>(256.0f * a_vec3Color.z);
    mathm::Clamp(b, 255, 0);
d117 8
a124 2
    return {r,g,b};
}
a125 2
vec3 renderer::CalculatePixelColor(bool bShadowRayOccluded, ray& aShadowRay, lightSource& lsALightSource, vec3& v3AIntersectionNormal, vec3& v3ObjectColor)
{
d127 1
a128 21
    if (!bShadowRayOccluded)
    {
        //TODO diffusion is still hardcoded, should be part of a material
        float fDiffusion = 0.9f;
    	
    	//calculate distance attenuation by dividing 1 by the length of the vector
    	//between the light source and the shadow rays origin squared
        vec3 v3VecToLight = lsALightSource.m_v3Position - aShadowRay.m_v3Origin;
        float fTempDistanceToLight = v3VecToLight.GetSquaredMagnitude();
        float fLightStrength = 1.0f / (fTempDistanceToLight);
    	

    	//calculating illumination by factoring in the angle of the light hitting the
    	//object & multiplying that with the diffusion of the material
        float fIlumination = aShadowRay.m_v3Direction.DotWith(v3AIntersectionNormal);
        mathm::Clamp(fIlumination, 1.0f, 0.0f);
        fIlumination *= fDiffusion;

    	
        v3LightAccumulation += lsALightSource.m_v3LightColor * fLightStrength * fIlumination;
    }
@


1.220586
log
@@
text
@a25 2
    vec3 v3PixelColor{};

a26 1
    float fDiffusion = 0.9f;
a56 4
            if (rPrimaryRay.m_iNearestPrimitiveIndex != 404)
            {
                int iIndex = rPrimaryRay.m_iNearestPrimitiveIndex;
                vec3 v3IntersectionNormal = m_p_prPrimitives[iIndex]->GetIntersectionNormal(isdPrimaryIntersections.m_v3IntersectionPoint);
d58 3
d62 4
a69 3
                vec3 v3LightAccumulation{};
                bool bLightOccluded = false;

d76 1
a78 15

                if (!bLightOccluded)
                {
                    vec3 v3VecToLight = lsPointLight.m_v3Position - rShadowRay.m_v3Origin;
                    float fTempDistanceToLight = v3VecToLight.GetMagnitude();
                    float fLightStrength = 1.0f / (fTempDistanceToLight * fTempDistanceToLight);

                    float fIlumination = rShadowRay.m_v3Direction.DotWith(v3IntersectionNormal);
                    mathm::Clamp(fIlumination, 1.0f, 0.0f);
                    fIlumination *= fDiffusion;

                    v3LightAccumulation = v3LightAccumulation + lsPointLight.m_v3LightColor * fLightStrength * fIlumination;
                }

                v3PixelColor = isdPrimaryIntersections.m_v3Color * v3LightAccumulation;
d81 5
a85 1

d118 28
@


1.219891
log
@@
text
@d18 1
d26 1
a26 2
    lightSource lsPointLight{ vec3{ 5, 10, -5 } , {}, {200,200,200}, 1 };
    float fDiffusion = 0.9f;
d28 2
d31 1
d41 1
a59 2
        	
            //
d63 4
a66 2
                vec3 v3IntersectionNormal = m_p_prPrimitives[iIndex]->getIntersectionNormal(isdPrimaryIntersections.m_v3IntersectionPoint);
            	
d70 2
d73 2
a74 1
                for (int j = 0; j <= 1; j++)
d76 5
d82 2
d88 3
a90 12
                    if (m_p_prPrimitives[j]->RayIntersection(rShadowRay, isdPrimaryIntersections))
                    {
                        rPrimaryRay.m_v3Color = {0,0,0};
                        break;

                    } else
                    {
                        float fIlumination = rShadowRay.m_v3Direction.DotWith(v3IntersectionNormal);
                        fIlumination *= fDiffusion;
                    	
                        rPrimaryRay.m_v3Color = rPrimaryRay.m_v3Color * rPrimaryRay.m_v3Color * lsPointLight.m_v3LightColor * fLightStrength * fIlumination;
                    }
d92 1
d94 2
d99 1
a99 1
            const rgbColor rgbTempColor = ConvertToRgb(rPrimaryRay.m_v3Color);
@


1.219624
log
@@
text
@d25 2
a26 1
    lightSource lsPointLight{ vec3{ 0, 20, -25 } , {}, 10};
d38 1
d42 1
a42 3
        	
            m_v3PixelColor = (0,0,0);

d45 4
a48 1
                if (m_p_prPrimitives[i]->RayIntersection(rPrimaryRay, m_isdPrimaryIntersections))
d50 1
a50 1
					//Debug: always sets new index, regardless of whether it is closer or not
d52 1
a53 5
            	
                //TODO replace with normal offset instead of direction offset
                rShadowRay = castShadowRay(m_isdPrimaryIntersections.m_v3IntersectionPoint, lsPointLight.m_v3Position,
                                           (m_p_prPrimitives[i]->m_v3Position -
	                                           m_isdPrimaryIntersections.m_v3IntersectionPoint).Normalize());
d56 3
a58 2
            //TODO replace with scenes
            for (int j = 0; j <= 1; j++)
d60 8
a67 1
                if (m_p_prPrimitives[j]->RayIntersection(rShadowRay, m_isdPrimaryIntersections))
d69 18
a86 3
                	//TODO change to correct color later
                    m_isdPrimaryIntersections.m_v3TransportedColor = (m_isdPrimaryIntersections.m_v3TransportedColor /*+ vec3{ 0,0,0 }*/) * 0.5f; 
                    break;
d88 1
a88 1
            }
d90 2
a91 7
        	//TODO
            if (rPrimaryRay.m_iNearestPrimitiveIndex != 404)
            {
                //m_v3PixelColor = m_p_prPrimitives[rPrimaryRay.m_iNearestPrimitiveIndex]->m_v3Color;
                m_v3PixelColor = m_isdPrimaryIntersections.m_v3TransportedColor;
            }
            const rgbColor rgbTempColor = ConvertToRgb(m_v3PixelColor);
d93 1
a93 1
            //this is taken from Jacco Bikkers "Hitting the ground running lecture"
d102 1
a102 1
ray& renderer::castShadowRay(vec3& aOrigin, vec3& aEndPoint, vec3& aCollideNormal)
d105 1
a105 1
	ray tempRay{aOrigin + aCollideNormal * 0.01f, v3Direction};
@


1.219071
log
@@
text
@d25 2
d38 1
d40 1
d45 1
a45 2
                //only for testing, should be shAllShapes[i].RayIntersection(rPrimaryRay)
                if ((m_p_prPrimitives[i]->RayIntersection(rPrimaryRay)).m_bIntersectionDetected)
d47 2
a48 2
                   //Debug: always sets new index, regardless of whether it is closer or not
                   rPrimaryRay.m_iNearestPrimitiveIndex = i; 
d50 5
a54 1
                m_isdPrimaryIntersections = m_p_prPrimitives[i]->RayIntersection(rPrimaryRay);
d57 10
a66 4
        	if(rPrimaryRay.m_iNearestPrimitiveIndex != 404)
        	{
                m_v3PixelColor = m_p_prPrimitives[rPrimaryRay.m_iNearestPrimitiveIndex]->m_v3Color;
        	}
d68 6
d85 8
@


1.218625
log
@@
text
@d42 1
a42 1
                if (m_p_prPrimitives[i]->RayIntersection(rPrimaryRay))
d44 2
a45 2
                    //Debug: always sets new index, regardless of whether it is closer or not
                    rPrimaryRay.m_iNearestPrimitiveIndex = i; 
d47 1
@


1.218287
log
@@
text
@d44 2
a45 1
                    rPrimaryRay.m_iNearestPrimitiveIndex = i;
d54 2
a55 10

            int r = static_cast<int>(256.0f * m_v3PixelColor.x);
            mathm::Clamp(r, 255, 0);

            int g = static_cast<int>(256.0f * m_v3PixelColor.y);
            mathm::Clamp(g, 255, 0);

            int b = static_cast<int>(256.0f * m_v3PixelColor.z);
            mathm::Clamp(b, 255, 0);

d57 1
a57 1
            pixels[y * SCRWIDTH + x] = b + (g << 8) + (r << 16); 
d64 14
@


1.217528
log
@@
text
@a1 1
#include "Renderer.h"
d3 1
a3 1
Renderer::Renderer()
d15 1
a15 1
Renderer::~Renderer()
d21 1
a21 1
void Renderer::Update()
d44 1
a44 1
                    m_v3PixelColor = m_p_prPrimitives[i]->m_v3Color;
d48 5
@


1.216991
log
@@
text
@d11 3
d38 3
a40 1
            for (int i = 0; i < 10; i++)
d43 1
a43 5
                if (m_spTestSphere.RayIntersection(rPrimaryRay))
                {
                    m_v3PixelColor = m_spTestSphere.m_v3Color;
                }
                else
d45 1
a45 1
                    m_v3PixelColor = {0,0,0};
@


1.216917
log
@@
text
@d21 2
a22 1
    SDL_RenderClear(m_p_reMainRenderer);
d24 3
d34 26
a62 2
    SDL_UpdateTexture(m_p_tMainTexture, NULL, pixels, (SCRWIDTH * sizeof(Uint32)));

@
